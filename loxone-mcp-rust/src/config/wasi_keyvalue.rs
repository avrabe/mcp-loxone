//! WASI keyvalue interface implementation
//!
//! This module provides credential storage using the WASI keyvalue interface
//! for use in WASM component environments.

#[cfg(feature = "wasi-keyvalue")]
use crate::error::{LoxoneError, Result};

#[cfg(feature = "wasi-keyvalue")]
mod wasi {
    //! WASI keyvalue bindings
    //!
    //! Note: These bindings would typically be generated by wit-bindgen
    //! from the official WASI keyvalue WIT definitions.

    use super::*;

    /// WASI keyvalue store interface
    pub struct Store {
        #[allow(dead_code)]
        name: Option<String>,
    }

    impl Store {
        /// Open a keyvalue store
        pub fn open(name: Option<String>) -> Result<Self> {
            Ok(Self { name })
        }

        /// Get a value by key
        pub async fn get(&self, key: &str) -> Result<Option<Vec<u8>>> {
            // This would be implemented using the actual WASI keyvalue interface
            // For now, we'll simulate the interface
            #[cfg(target_arch = "wasm32")]
            {
                self.wasm_get(key).await
            }
            #[cfg(not(target_arch = "wasm32"))]
            {
                // Fallback for non-WASM environments (testing, etc.)
                use std::collections::HashMap;
                use std::sync::Mutex;

                static MOCK_STORE: Mutex<Option<HashMap<String, Vec<u8>>>> = Mutex::new(None);

                let store = MOCK_STORE.lock().unwrap();
                if let Some(ref store) = *store {
                    Ok(store.get(key).cloned())
                } else {
                    Ok(None)
                }
            }
        }

        /// Set a key-value pair
        pub async fn set(&self, key: &str, value: Vec<u8>) -> Result<()> {
            #[cfg(target_arch = "wasm32")]
            {
                self.wasm_set(key, value).await
            }
            #[cfg(not(target_arch = "wasm32"))]
            {
                // Fallback for non-WASM environments
                use std::collections::HashMap;
                use std::sync::Mutex;

                static MOCK_STORE: Mutex<Option<HashMap<String, Vec<u8>>>> = Mutex::new(None);

                let mut store = MOCK_STORE.lock().unwrap();
                if store.is_none() {
                    *store = Some(HashMap::new());
                }
                store.as_mut().unwrap().insert(key.to_string(), value);
                Ok(())
            }
        }

        /// Delete a key
        pub async fn delete(&self, key: &str) -> Result<()> {
            #[cfg(target_arch = "wasm32")]
            {
                self.wasm_delete(key).await
            }
            #[cfg(not(target_arch = "wasm32"))]
            {
                // Fallback for non-WASM environments
                use std::collections::HashMap;
                use std::sync::Mutex;

                static MOCK_STORE: Mutex<Option<HashMap<String, Vec<u8>>>> = Mutex::new(None);

                let mut store = MOCK_STORE.lock().unwrap();
                if let Some(ref mut store) = *store {
                    store.remove(key);
                }
                Ok(())
            }
        }

        /// List all keys
        pub async fn list_keys(&self) -> Result<Vec<String>> {
            #[cfg(target_arch = "wasm32")]
            {
                self.wasm_list_keys().await
            }
            #[cfg(not(target_arch = "wasm32"))]
            {
                // Fallback for non-WASM environments
                use std::collections::HashMap;
                use std::sync::Mutex;

                static MOCK_STORE: Mutex<Option<HashMap<String, Vec<u8>>>> = Mutex::new(None);

                let store = MOCK_STORE.lock().unwrap();
                if let Some(ref store) = *store {
                    Ok(store.keys().cloned().collect())
                } else {
                    Ok(Vec::new())
                }
            }
        }
    }

    #[cfg(target_arch = "wasm32")]
    impl Store {
        async fn wasm_get(&self, key: &str) -> Result<Option<Vec<u8>>> {
            // In a real implementation, this would use the WASI keyvalue interface
            // Generated bindings would look something like:
            //
            // use wasi::keyvalue::store;
            // let bucket = store::open(&self.name.as_deref().unwrap_or("default"))?;
            // match bucket.get(key) {
            //     Ok(Some(value)) => Ok(Some(value)),
            //     Ok(None) => Ok(None),
            //     Err(e) => Err(LoxoneError::credentials(format!("WASI keyvalue error: {:?}", e))),
            // }

            // For now, use a JavaScript-based fallback that simulates WASI behavior
            use wasm_bindgen::prelude::*;

            #[wasm_bindgen]
            extern "C" {
                #[wasm_bindgen(js_namespace = console)]
                fn log(s: &str);
            }

            // Use IndexedDB or localStorage as a fallback
            let window = web_sys::window()
                .ok_or_else(|| LoxoneError::credentials("No window object available"))?;

            let storage = window
                .local_storage()
                .map_err(|_| LoxoneError::credentials("Local storage not available"))?
                .ok_or_else(|| LoxoneError::credentials("Local storage is None"))?;

            let prefixed_key = format!("wasi_kv:{}", key);
            match storage.get_item(&prefixed_key) {
                Ok(Some(value)) => {
                    // Decode base64-encoded value
                    use base64::Engine;
                    let decoded = base64::engine::general_purpose::STANDARD
                        .decode(value)
                        .map_err(|e| {
                            LoxoneError::credentials(format!("Failed to decode value: {}", e))
                        })?;
                    Ok(Some(decoded))
                }
                Ok(None) => Ok(None),
                Err(_) => Err(LoxoneError::credentials(
                    "Failed to access WASI keyvalue store",
                )),
            }
        }

        async fn wasm_set(&self, key: &str, value: Vec<u8>) -> Result<()> {
            // Use localStorage as a fallback
            let window = web_sys::window()
                .ok_or_else(|| LoxoneError::credentials("No window object available"))?;

            let storage = window
                .local_storage()
                .map_err(|_| LoxoneError::credentials("Local storage not available"))?
                .ok_or_else(|| LoxoneError::credentials("Local storage is None"))?;

            // Encode value as base64
            use base64::Engine;
            let encoded = base64::engine::general_purpose::STANDARD.encode(&value);

            let prefixed_key = format!("wasi_kv:{}", key);
            storage
                .set_item(&prefixed_key, &encoded)
                .map_err(|_| LoxoneError::credentials("Failed to store in WASI keyvalue store"))?;

            Ok(())
        }

        async fn wasm_delete(&self, key: &str) -> Result<()> {
            let window = web_sys::window()
                .ok_or_else(|| LoxoneError::credentials("No window object available"))?;

            let storage = window
                .local_storage()
                .map_err(|_| LoxoneError::credentials("Local storage not available"))?
                .ok_or_else(|| LoxoneError::credentials("Local storage is None"))?;

            let prefixed_key = format!("wasi_kv:{}", key);
            storage.remove_item(&prefixed_key).map_err(|_| {
                LoxoneError::credentials("Failed to delete from WASI keyvalue store")
            })?;

            Ok(())
        }

        async fn wasm_list_keys(&self) -> Result<Vec<String>> {
            let window = web_sys::window()
                .ok_or_else(|| LoxoneError::credentials("No window object available"))?;

            let storage = window
                .local_storage()
                .map_err(|_| LoxoneError::credentials("Local storage not available"))?
                .ok_or_else(|| LoxoneError::credentials("Local storage is None"))?;

            let length = storage
                .length()
                .map_err(|_| LoxoneError::credentials("Failed to get storage length"))?;

            let mut keys = Vec::new();
            let prefix = "wasi_kv:";

            for i in 0..length {
                if let Ok(Some(key)) = storage.key(i) {
                    if key.starts_with(prefix) {
                        keys.push(key[prefix.len()..].to_string());
                    }
                }
            }

            Ok(keys)
        }
    }
}

#[cfg(feature = "wasi-keyvalue")]
pub use wasi::Store;

#[cfg(feature = "wasi-keyvalue")]
pub struct WasiKeyValueManager {
    store: Store,
    prefix: String,
}

#[cfg(feature = "wasi-keyvalue")]
impl WasiKeyValueManager {
    /// Create a new WASI keyvalue manager
    pub fn new(store_name: Option<String>) -> Result<Self> {
        let store = Store::open(store_name)?;
        let prefix = "loxone_mcp:".to_string();

        Ok(Self { store, prefix })
    }

    /// Get a credential value
    pub async fn get_credential(&self, key: &str) -> Result<Option<String>> {
        let prefixed_key = format!("{}{}", self.prefix, key);

        match self.store.get(&prefixed_key).await? {
            Some(bytes) => {
                let value = String::from_utf8(bytes).map_err(|e| {
                    LoxoneError::credentials(format!("Invalid UTF-8 in stored credential: {}", e))
                })?;
                Ok(Some(value))
            }
            None => Ok(None),
        }
    }

    /// Set a credential value
    pub async fn set_credential(&self, key: &str, value: &str) -> Result<()> {
        let prefixed_key = format!("{}{}", self.prefix, key);
        self.store
            .set(&prefixed_key, value.as_bytes().to_vec())
            .await
    }

    /// Delete a credential
    pub async fn delete_credential(&self, key: &str) -> Result<()> {
        let prefixed_key = format!("{}{}", self.prefix, key);
        self.store.delete(&prefixed_key).await
    }

    /// List all credential keys
    pub async fn list_credentials(&self) -> Result<Vec<String>> {
        let all_keys = self.store.list_keys().await?;

        let credential_keys: Vec<String> = all_keys
            .into_iter()
            .filter_map(|key| {
                if key.starts_with(&self.prefix) {
                    Some(key[self.prefix.len()..].to_string())
                } else {
                    None
                }
            })
            .collect();

        Ok(credential_keys)
    }

    /// Clear all credentials
    pub async fn clear_all_credentials(&self) -> Result<()> {
        let credential_keys = self.list_credentials().await?;

        for key in credential_keys {
            self.delete_credential(&key).await?;
        }

        Ok(())
    }
}

#[cfg(test)]
mod tests {
    #[cfg(all(feature = "wasi-keyvalue", target_arch = "wasm32"))]
    use super::*;

    #[cfg(all(feature = "wasi-keyvalue", target_arch = "wasm32"))]
    #[tokio::test]
    async fn test_wasi_keyvalue_manager() {
        let manager = WasiKeyValueManager::new(None).unwrap();

        // Test set and get
        manager
            .set_credential("test_key", "test_value")
            .await
            .unwrap();
        let value = manager.get_credential("test_key").await.unwrap();
        assert_eq!(value, Some("test_value".to_string()));

        // Test list
        let keys = manager.list_credentials().await.unwrap();
        assert!(keys.contains(&"test_key".to_string()));

        // Test delete
        manager.delete_credential("test_key").await.unwrap();
        let value = manager.get_credential("test_key").await.unwrap();
        assert_eq!(value, None);
    }
}
